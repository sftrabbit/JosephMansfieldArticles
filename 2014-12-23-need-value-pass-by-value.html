---
layout: article
title: Need a value? Pass by value
description: "Pass by value or by <code>const</code> reference &mdash; why is the simple task of writing function parameters so complicated in C++? Instead, let's keep it simple."
tag: C++
---
<p>C++ experts have a tendency to overcomplicate the language's best practices through rigorous academic discussions about the optimality of every possible line of code. This makes it difficult to learn C++ because the rules are complicated and a consensus is difficult to find.</p>
<p>One particular case that I have come across a lot recently is the choice of whether to take a parameter by value or by <code>const</code> reference. These can both used for the same purpose &mdash; to get the value of the passed argument. After all, either will except any object of the correct type (whether temporary or not). For a long time, passing by <code>const</code> reference was popular for anything that wasn't a primitive type, to save from expensive copies. Since C++11 and the introduction of move semantics, the commonly accepted practice is to pass by value only when your function is going to need a copy anyway &mdash; allowing the move constructor to be used when the caller passes a temporary object and allowing the function to use <code>std::move</code> internally where appropriate. More recently, <a href="https://www.youtube.com/watch?v=xnqTKD8uD64">Herb Sutter gave evidence</a> that using a <code>const</code> reference might actually more optimal in certain situations.</p>
<p>However, there are a few problems with all this discussion:</p>
<ul>
	<li>We're overcomplicating our function interfaces. We now have two things, value types and <code>const</code> references, that say the same thing to the caller: I need the value of your object. A C++ programmer has to know this to understand interfaces and also needs to know how to use each approach when designing their own functions. A beginner shouldn't have to know the details of move semantics and copy optimizations just to write some function parameters.</li>
	<li>A <code>const</code> reference <em>could</em> mean something else. If a function asks for a reference to your object, you might question it. Is it going to keep this reference? Do you need to ensure an extended lifetime of your object? Is it going to care if I pass an object that is only convertible to the parameter type? This isn't clear from the parameter types alone. Passing by value, on the other hand, is very clear &mdash; it doesn't care about the object you give, just the value it provides.</li>
	<li><code>const</code> references are often a premature optimization, which we know is the <a href="http://c2.com/cgi/wiki?PrematureOptimization">"root of all evil"</a>. The execution time cost of a copy is typically in the order of nanoseconds and the memory cost is of course as large as the object's state. It is often mitigated by copy elision and move semantics. Unless you're copying very frequently in a time or space critical part of your program, do you really need to complicate your interfaces for the sake of unnecessary optimizations? For the most part, optimization should be the compilers job &mdash; the programmer should only step in when necessary.</li>
</ul>
<p>For these reasons, I consider a <code>const</code> reference argument being used for the sake of optimization a <i>messy optimization</i>. It's an optimization that ruins the simplicity and readability of your interfaces, so it had better be worth it. Simplicity and readability come first &mdash; optimize later when you measure that there's a performance problem.</p>
<p>So what if you do measure that there's a problem? Are you copying objects around that don't really need to be copied? Are those copies expensive? If so, I don't think that <code>const</code> references should be your first port of call. First try something like the <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> mechanism, in which the internals of an object are only copied when written to. This way, an expensive copy is only performed when necessary and your function interfaces remain exactly the same (the copy-on-write is hidden from the user). If copy-on-write doesn't help &mdash; and <a href="http://www.gotw.ca/publications/optimizations.htm">there is evidence</a> that it might lead to bad performance when implemented for multi-threaded environments &mdash; then try something else. Sure, <code>const</code> references might be appropriate at this point. However, you should only use them when necessary, isolate them to a specific region of your code, and document their use. A reference parameter intrudes on the caller's space. I don't want to have to wonder why your function wants a reference to my object &mdash; just tell me.</p>
<p>This effectively reduces the genuine uses of <code>const</code> references down to when we actually require immutable access to the caller's object. That is, when the fact that it is the caller's object is very important to us. In these cases, we typically want to track changes to the value of that particular object. This situation occurs significantly less often than we use <code>const</code> references today.</p>
<p>So let's keep it simple: <b>Need a value? Pass by value.</b> It's a rule that is easy to understand, simple to teach, and gives us safe interfaces and readable code. Optimize later.</p>
